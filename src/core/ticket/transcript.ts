import discord from 'discord.js';
import { DataSource } from 'typeorm';
import { createTranscript } from 'discord-html-transcripts';

import client from '../../salt';
import { TicketRepository } from '../../events/database/repo/ticket_system';

/**
 * Utility class for handling ticket transcripts
 * Provides methods for creating, sending, and managing ticket transcripts
 */
export class TicketTranscript {
	private ticketRepo: TicketRepository;

	constructor(dataSource: DataSource) {
		this.ticketRepo = new TicketRepository(dataSource);
	}

	/**
	 * Create a transcript for a ticket channel
	 * @param channel - Discord text channel
	 * @param ticketNumber - Ticket number for filename
	 * @returns Promise resolving to attachment buffer or null
	 */
	public createTranscript = async (channel: discord.TextChannel, ticketNumber: number): Promise<discord.AttachmentBuilder | null> => {
		try {
			const attachment = await createTranscript(channel, {
				limit: 10000,
				saveImages: true,
				poweredBy: false,
				filename: `ticket-${ticketNumber}.html`,
			});

			return attachment as discord.AttachmentBuilder;
		} catch (error) {
			client.logger.error(`[TICKET_TRANSCRIPT] Error creating transcript: ${error}`);
			return null;
		}
	};

	/**
	 * Send transcript to a user via DM
	 * @param user - Discord user to send transcript to
	 * @param attachment - Transcript attachment
	 * @param ticketInfo - Ticket information
	 * @returns Promise resolving to success status
	 */
	public sendTranscriptToUser = async (
		user: discord.User,
		attachment: discord.AttachmentBuilder,
		ticketInfo: {
			ticketNumber: number;
			guildName: string;
			categoryName: string;
			generatedBy: string;
		}
	): Promise<boolean> => {
		try {
			const embed = new discord.EmbedBuilder()
				.setTitle(`Ticket #${ticketInfo.ticketNumber} Transcript`)
				.setDescription(`Transcript from **${ticketInfo.guildName}**\n` + `**Ticket Number:** ${ticketInfo.ticketNumber}\n` + `**Category:** ${ticketInfo.categoryName}\n` + `**Generated by:** ${ticketInfo.generatedBy}`)
				.setColor('#2F3136')
				.setFooter({
					text: 'Transcript generated on request',
					iconURL: client.user?.displayAvatarURL(),
				})
				.setTimestamp();

			await user.send({
				embeds: [embed],
				files: [attachment],
			});

			return true;
		} catch (error) {
			client.logger.error(`[TICKET_TRANSCRIPT] Failed to send transcript to user: ${error}`);
			return false;
		}
	};

	/**
	 * Send transcript to a channel
	 * @param channel - Discord text channel
	 * @param attachment - Transcript attachment
	 * @param ticketInfo - Ticket information
	 * @returns Promise resolving to success status
	 */
	public sendTranscriptToChannel = async (
		channel: discord.TextChannel,
		attachment: discord.AttachmentBuilder,
		ticketInfo: {
			ticketNumber: number;
			creatorId: string;
			categoryName: string;
			status: string;
			createdAt: Date;
			closedBy?: string;
			closeReason?: string;
		}
	): Promise<boolean> => {
		try {
			const creator = await client.users.fetch(ticketInfo.creatorId).catch(() => null);
			let closedByUser = null;
			if (ticketInfo.closedBy) {
				closedByUser = await client.users.fetch(ticketInfo.closedBy).catch(() => null);
			}

			const embed = new discord.EmbedBuilder()
				.setTitle(`Ticket #${ticketInfo.ticketNumber} Transcript`)
				.setDescription(`**User:** ${creator ? creator.tag : 'Unknown'} (${ticketInfo.creatorId})\n` + `**Category:** ${ticketInfo.categoryName}\n` + `**Status:** ${ticketInfo.status.toUpperCase()}\n` + `**Created:** <t:${Math.floor(ticketInfo.createdAt.getTime() / 1000)}:F>`)
				.setColor('#2F3136')
				.setFooter({
					text: 'Automated transcript generation',
					iconURL: client.user?.displayAvatarURL(),
				})
				.setTimestamp();

			if (ticketInfo.closedBy && closedByUser) {
				embed.addFields({ name: 'Closed By', value: closedByUser.tag, inline: true }, { name: 'Close Reason', value: ticketInfo.closeReason || 'No reason provided', inline: true });
			}

			await channel.send({
				embeds: [embed],
				files: [attachment],
			});

			return true;
		} catch (error) {
			client.logger.error(`[TICKET_TRANSCRIPT] Failed to send transcript to channel: ${error}`);
			return false;
		}
	};

	/**
	 * Create and send transcript automatically when ticket is closed
	 * @param channelId - Ticket channel ID
	 * @param closedByUser - User who closed the ticket
	 * @param closeReason - Reason for closing
	 * @param ticketId - Ticket database ID
	 * @returns Promise resolving to success status
	 */
	public createAndSendTranscript = async (channelId: string, closedByUser: discord.User, closeReason: string, ticketId: string): Promise<boolean> => {
		try {
			const ticket = await this.ticketRepo.getTicket(ticketId);
			if (!ticket) {
				client.logger.error('[TICKET_TRANSCRIPT] Ticket not found for transcript generation');
				return false;
			}

			const channel = client.channels.cache.get(channelId) as discord.TextChannel;
			if (!channel) {
				client.logger.error('[TICKET_TRANSCRIPT] Channel not found for transcript generation');
				return false;
			}

			const attachment = await this.createTranscript(channel, ticket.ticketNumber);
			if (!attachment) {
				return false;
			}

			const buttonConfig = await this.ticketRepo.getTicketButtonConfig(channel.guildId);
			if (buttonConfig?.logChannelId) {
				const transcriptChannel = client.channels.cache.get(buttonConfig.logChannelId) as discord.TextChannel;
				if (transcriptChannel) {
					await this.sendTranscriptToChannel(transcriptChannel, attachment, {
						ticketNumber: ticket.ticketNumber,
						creatorId: ticket.creatorId,
						categoryName: ticket.category.name,
						status: ticket.status,
						createdAt: ticket.createdAt,
						closedBy: closedByUser.id,
						closeReason: closeReason,
					});
				}
			}

			client.logger.info(`[TICKET_TRANSCRIPT] Generated transcript for ticket #${ticket.ticketNumber}`);
			return true;
		} catch (error) {
			client.logger.error(`[TICKET_TRANSCRIPT] Error in createAndSendTranscript: ${error}`);
			return false;
		}
	};
}
